import nu.pattern.OpenCV;
import org.opencv.core.*;
import org.opencv.imgproc.Imgproc;
import org.opencv.objdetect.CascadeClassifier;
import org.opencv.videoio.VideoCapture;

import javax.swing.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;

public class Main {
    public static void main(String[] args) {
        // --- 1. INITIALIZATION ---

        // Load the native OpenCV libraries.
        OpenCV.loadLocally();

        // Load the pre-trained face detection model.
        CascadeClassifier faceDetector = loadFaceDetector();
        if (faceDetector == null) {
            System.out.println("Error loading face detector!");
            return;
        }

        // --- 2. CAMERA AND UI SETUP ---

        VideoCapture camera = new VideoCapture(0);
        if (!camera.isOpened()) {
            System.out.println("Error: Cannot open camera!");
            return;
        }

        JFrame window = new JFrame("IMentia - Face Detection");
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.setSize(800, 600);

        JLabel imageLabel = new JLabel();
        imageLabel.setHorizontalAlignment(JLabel.CENTER);
        window.add(imageLabel);
        window.setVisible(true);

        // --- 3. IMAGE CONTAINERS ---

        Mat frame = new Mat();
        Mat grayFrame = new Mat();

        System.out.println("Running... Close the window to stop.");

        // --- 4. MAIN VIDEO LOOP ---

        while (window.isVisible()) {
            if (!camera.read(frame)) {
                continue;
            }

            // Convert to grayscale for detection
            Imgproc.cvtColor(frame, grayFrame, Imgproc.COLOR_BGR2GRAY);

            // Detect faces
            MatOfRect detections = new MatOfRect();
            faceDetector.detectMultiScale(grayFrame, detections);

            // Draw rectangles around faces
            for (Rect rect : detections.toArray()) {
                Imgproc.rectangle(
                    frame,
                    new Point(rect.x, rect.y),
                    new Point(rect.x + rect.width, rect.y + rect.height),
                    new Scalar(0, 255, 0),
                    3
                );
            }

            // Convert Mat to BufferedImage and display
            BufferedImage image = matToBufferedImage(frame);
            imageLabel.setIcon(new ImageIcon(image));

            try {
                Thread.sleep(30);
            } catch (InterruptedException e) {
                break;
            }
        }

        // --- 5. CLEANUP ---

        camera.release();
        window.dispose();
    }

    /**
     * Loads the haarcascade XML file which is packaged as a project resource.
     * OpenCV's CascadeClassifier requires a physical file path, so we must
     * copy the resource stream to a temporary file on the filesystem.
     */
    private static CascadeClassifier loadFaceDetector() {
        try {
            // STEP 1: Access the 'Nested' Resource as a Stream
            // getResourceAsStream looks inside the compiled application (JAR/classpath)
            // for the file. The leading '/' searches from the root of the resources folder.
            InputStream is = Main.class.getResourceAsStream("/haarcascade_frontalface_default.xml");
            if (is == null) {
                System.out.println("Could not find haarcascade file! Ensure it is in the resources folder.");
                return null;
            }

            // STEP 2: Create a Temporary File Path for OpenCV
            // OpenCV cannot read from an InputStream, so we must write the bytes to a disk file.
            File tempFile = File.createTempFile("haarcascade", ".xml");
            // Important: This ensures the temporary file is deleted automatically on program exit.
            tempFile.deleteOnExit();

            // STEP 3: Copy Data from the Resource Stream to the Temporary File
            FileOutputStream os = new FileOutputStream(tempFile);
            byte[] buffer = new byte[4096];
            int bytesRead;

            // Read chunks of data from the InputStream and write them to the FileOutputStream.
            while ((bytesRead = is.read(buffer)) != -1) {
                os.write(buffer, 0, bytesRead);
            }
            is.close();
            os.close();

            // STEP 4: Initialize the Classifier from the Disk Path
            // Now we pass the absolute path of the physical file to the CascadeClassifier.
            CascadeClassifier classifier = new CascadeClassifier(tempFile.getAbsolutePath());

            if (classifier.empty()) {
                // This checks if the XML data was loaded successfully.
                System.out.println("CascadeClassifier failed to load the XML data.");
                return null;
            }
            return classifier;

        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Converts an OpenCV Mat object into a Java BufferedImage for display in Swing.
     */
    private static BufferedImage matToBufferedImage(Mat mat) {
        int type = BufferedImage.TYPE_3BYTE_BGR;
        if (mat.channels() == 1) {
            type = BufferedImage.TYPE_BYTE_GRAY;
        }

        // Create empty BufferedImage
        BufferedImage image = new BufferedImage(mat.width(), mat.height(), type);

        // Byte array to hold raw pixel data from Mat.
        byte[] data = new byte[mat.width() * mat.height() * (int) mat.elemSize()];

        // Copy Mat's pixels into the 'data' array.
        mat.get(0, 0, data);

        // Get a reference (pointer) to the BufferedImage's internal pixel array.
        byte[] pixels = ((java.awt.image.DataBufferByte) image.getRaster().getDataBuffer()).getData();

        // Copy the Mat's data into the BufferedImage's internal array, updating the image instantly.
        System.arraycopy(data, 0, pixels, 0, data.length);

        return image;
    }
}